<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC下runtime获取类私有成员属性 · RecherJ's blog</title><meta name="description" content="OC下runtime获取类私有成员属性 - RecherJ"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://recherj.github.io/atom.xml" title="RecherJ's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2698628733" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/RecherJ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC下runtime获取类私有成员属性</h1><div class="post-info">Apr 18, 2016</div><div class="post-content"><p>苹果的runtime运行机制还是非常强大的，掌握runtime对开发帮助是如虎添翼。因为有些类的私有成员属性是不暴漏在外供开发者使用的，但是有时，如果我们知道了这些属性对开发来说事半功倍，省去很多麻烦。</p>
<a id="more"></a>
<p>下面介绍一个runtime中的C语言函数，可以找出这些藏在类中的私有成员属性。使用方法也很简单，首先导入头文件<code>#import &quot;objc/runtime.h&quot;</code>,这样就可以敲出下面这个方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p>
<p>两个参数：第一个传入你想获取的类，第二个传入一个整型的总数count的地址，它会返回这个总数给你。<br>这个函数返回的是一个Ivar类型的指针对象，该指针指向每一个属性的地址，其实就是一个数组，遍历这个数组，就可以取出所有的私有成员变量了。<br><strong>注意点</strong>：该列表返回的属性中，只有本来的私有成员属性，不包含继承父类的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    <span class="comment">//获取属性名</span></span><br><span class="line">    <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ivarName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到私有的成员属性后，就可以利用KVC来取出对应的值，非常方便。</p>
<p>例如，可以利用这个方法在系统手势的基础上，增加一个自定义的返回手势</p>
<p>系统的返回手势，只有在靠近左边滑动时才会有返回效果，如果我们希望在中间向右滑动也有返回效果的话，我们可以自己添加一个手势，将其添加到导航控制的View上，调用系统自带的target选择子，来实现该功能</p>
<p>首先，禁用系统自带的滑动返回手势<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure></p>
<p>新建一个手势，将其添加到导航控制器View上<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure></p>
<p>这里target对象就是利用KVC模式取出的target</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *targets= [<span class="keyword">self</span>.interactivePopGestureRecognizer valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line"><span class="keyword">id</span> objc = [targets firstObject];</span><br><span class="line"><span class="keyword">id</span> target = [objc valueForKeyPath:<span class="string">@"_target"</span>];</span><br></pre></td></tr></table></figure>
<p>这样即使滑动中间也会有返回手势了，并且与系统自带的靠边返回不冲突。但是，如果当前的导航控制的栈顶控制器是自身的话，我们其实是需要将这个手势禁用的。因为，当前栈中已经没有需要出栈的控制器了。<br><code>UIGestureRecognizerDelegate</code>代理方法中有一个监听手势是否可用的方法，返回YES时手势可用。<br>给刚才自己添加的pan手势设置代理<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pan.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure></p>
<p>遵守<code>UIGestureRecognizerDelegate</code>协议<br>当栈顶控制不等于自己时返回YES，如果是自己就返回NO,禁用自定义的手势</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.topViewController != [<span class="keyword">self</span>.viewControllers firstObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就给利用运行时机制和系统自带的手势识别给系统增加了一个我们自定义的手势。</p>
<p><img src="/img/返回手势.gif" alt="效果图"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/18/Mac下利用github和Hexo搭建个人博客（二）/" class="prev">PREV</a><a href="/2016/04/17/linker-command-failed-with-exit-code-1-use-vto-see-invocation-原因和解决/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="https://recherj.github.io">RecherJ</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>