<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RecherJ&#39;s blog</title>
  
  <subtitle>现在的年轻人，一言不合就贴代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://recherj.github.io/"/>
  <updated>2018-06-03T10:24:40.648Z</updated>
  <id>https://recherj.github.io/</id>
  
  <author>
    <name>RecherJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仿淘宝购买页面</title>
    <link href="https://recherj.github.io/2018/06/03/%E4%BB%BF%E6%B7%98%E5%AE%9D%E8%B4%AD%E4%B9%B0%E9%A1%B5%E9%9D%A2/"/>
    <id>https://recherj.github.io/2018/06/03/仿淘宝购买页面/</id>
    <published>2018-06-03T09:39:40.000Z</published>
    <updated>2018-06-03T10:24:40.648Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，公司的设计小妹子觉得手淘iOS的那个加入购物车、购买时的动画效果很好，所以也要求我们做一个类似的，因为维语文字的排列方向时从右至左的，所以再仔细观察了淘宝的动画后，也仿写了一个类似样式的。<br><a id="more"></a></p><p>直接上效果图</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fry5xj5f5pg30ao0ixe81.gif" alt="效果图"></p><p>其实思路很简单：利用 <code>touchMoved</code> 和 <code>touchedEnded</code> 两个方法，计算手势移动的距离差计算出一个比例，结合view的transform变化完成。</p><p>核心代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> touch = touches.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 1. 移动下面的view</span></span><br><span class="line">        <span class="keyword">let</span> parentViewP = touch.location(<span class="keyword">in</span>: parentView)</span><br><span class="line">  <span class="comment">// parentView 即下面两个种规格和下面购买数量的父视图</span></span><br><span class="line">        <span class="keyword">let</span> prevParentViewP = touch.previousLocation(<span class="keyword">in</span>: parentView)</span><br><span class="line">        <span class="keyword">let</span> offsetY = parentViewP.y - prevParentViewP.y</span><br><span class="line">        </span><br><span class="line">        parentView.y += offsetY</span><br><span class="line">        <span class="comment">// 限制移动范围</span></span><br><span class="line">        <span class="keyword">if</span> parentView.y &lt; <span class="number">125</span> &#123; <span class="comment">// parentView 起始坐标 10 + 100 + 15</span></span><br><span class="line">            parentView.y = <span class="number">125</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> parentView.y &gt; <span class="number">300</span> &#123;</span><br><span class="line">            parentView.y = <span class="number">300</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 缩放商品图片</span></span><br><span class="line">        <span class="keyword">let</span> ratio = (parentView.y - <span class="number">125</span>) / (<span class="number">300</span> - <span class="number">125</span>)</span><br><span class="line">        goodImage.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">0.5</span> + ratio * <span class="number">0.5</span>, y: <span class="number">0.5</span> + ratio * <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">let</span> delta = kScreenWidth * <span class="number">0.5</span> - <span class="number">200</span> * <span class="number">0.5</span> - <span class="number">10</span></span><br><span class="line">        goodImage.layer.position = <span class="type">CGPoint</span>(x: kScreenWidth - <span class="number">10</span> - delta * ratio, y: <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 3. 移动价格</span></span><br><span class="line">        price.layer.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">1.0</span>, y: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">let</span> startX = kScreenWidth - <span class="number">100</span> - <span class="number">10</span> * <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> endX = price.width * <span class="number">0.5</span> + kScreenWidth * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">let</span> priceDelta = endX - startX</span><br><span class="line">        price.layer.position = <span class="type">CGPoint</span>(x: startX + ratio * priceDelta, y: <span class="number">10</span> + ratio * (<span class="number">215</span> - <span class="number">10</span>))</span><br><span class="line">        <span class="comment">// 4. 移动选择的尺寸</span></span><br><span class="line">        <span class="keyword">let</span> sizeStartX = kScreenWidth - <span class="number">100</span> - <span class="number">10</span> * <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> sizeEndX = choosedsizeLabel.width * <span class="number">0.5</span> + kScreenWidth * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">let</span> sizeDelta = sizeEndX - sizeStartX</span><br><span class="line">        choosedsizeLabel.layer.position = <span class="type">CGPoint</span>(x: <span class="number">1.0</span>, y: <span class="number">0</span>)</span><br><span class="line">        choosedsizeLabel.layer.position = <span class="type">CGPoint</span>(x: sizeStartX + ratio * sizeDelta, y: <span class="number">35</span> + ratio * (<span class="number">215</span> - <span class="number">10</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是为了结束移动时，如果位置不是起始或终止位置，进行一个变换</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parentView.y &gt; <span class="number">125</span> + <span class="number">87.5</span> &#123; <span class="comment">// 移动到了放大区域内，放大</span></span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.parentView.y = <span class="number">300</span></span><br><span class="line">                <span class="keyword">self</span>.goodImage.layer.position = <span class="type">CGPoint</span>(x: kScreenWidth - <span class="number">10</span> - (kScreenWidth * <span class="number">0.5</span> - <span class="number">200</span> * <span class="number">0.5</span> - <span class="number">10</span>), y: <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">self</span>.goodImage.transform = .identity</span><br><span class="line">                <span class="keyword">self</span>.price.layer.position = <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.price.width * <span class="number">0.5</span> + kScreenWidth * <span class="number">0.5</span> , y: <span class="number">215</span>)</span><br><span class="line">                <span class="keyword">self</span>.choosedsizeLabel.layer.position = <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.choosedsizeLabel.width * <span class="number">0.5</span> + kScreenWidth * <span class="number">0.5</span>, y: <span class="number">35</span> + <span class="number">205</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 移动到了缩小区域内，缩小</span></span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.parentView.y = <span class="number">125</span></span><br><span class="line">                <span class="keyword">self</span>.goodImage.layer.position = <span class="type">CGPoint</span>(x: kScreenWidth - <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">self</span>.goodImage.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">0.5</span>, y: <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">self</span>.price.layer.position = <span class="type">CGPoint</span>(x: kScreenWidth - <span class="number">100</span> - <span class="number">10</span> * <span class="number">2</span>, y: <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">self</span>.choosedsizeLabel.layer.position = <span class="type">CGPoint</span>(x: kScreenWidth - <span class="number">100</span> - <span class="number">10</span> * <span class="number">2</span>, y: <span class="number">35</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里里面的一些魔法数字都是人为规定的，可以根据大小位置进行相应调整。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，公司的设计小妹子觉得手淘iOS的那个加入购物车、购买时的动画效果很好，所以也要求我们做一个类似的，因为维语文字的排列方向时从右至左的，所以再仔细观察了淘宝的动画后，也仿写了一个类似样式的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重拾博客</title>
    <link href="https://recherj.github.io/2018/05/06/%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2/"/>
    <id>https://recherj.github.io/2018/05/06/重拾博客/</id>
    <published>2018-05-06T06:38:37.000Z</published>
    <updated>2018-05-06T06:58:25.820Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直督促自己要把荒废的博客捡起来，之前搭建这个也是为了督促自己学习、写作、不断巩固学到的知识。</p><a id="more"></a><blockquote><p>懒得真是自己最大的敌人</p></blockquote><p>今天看了下，16年时还记录的蛮多，整个17年就荒废了，说好的知识点、读书笔记呢？？真是惭愧惭愧…</p><p>这个博客主题也从最开始 <a href="http://lotabout.me/very-simple/" target="_blank" rel="noopener">very simple</a> 到后面的 <a href="https://github.com/probberechts/hexo-theme-cactus" target="_blank" rel="noopener">cactus-dark</a> 再多现在的 <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">apollo</a> ，最终定下这款主题，也是因为简洁大方，就看不厌，毕竟一个良好美观的界面也会让自己坚持下去 [一个颜值党的自我安慰🤣]</p><p>后面的目标是讲在作者的基础修改，因为这也不是我最终想要的效果，后面一点点完成，也算是给自己立个flag吧。</p><p>今年也有很多可写的，最后都因为懒惰没有付诸行动。</p><p>不能懒不能懒不能懒，重要的事说三遍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直督促自己要把荒废的博客捡起来，之前搭建这个也是为了督促自己学习、写作、不断巩固学到的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随感" scheme="https://recherj.github.io/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>初识CATextLayer</title>
    <link href="https://recherj.github.io/2017/02/03/%E5%88%9D%E8%AF%86CATextLayer/"/>
    <id>https://recherj.github.io/2017/02/03/初识CATextLayer/</id>
    <published>2017-02-03T03:17:25.000Z</published>
    <updated>2018-05-06T10:14:36.112Z</updated>
    
    <content type="html"><![CDATA[<p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。</p><a id="more"></a><p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用 <code>Core Graphics</code> 写入图层的内 容(<strong>这就是UILabel的精髓</strong>)。如果越过寄宿于图层的视图,直接在图层上操作,那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类,还要逻辑上判断哪个图层需要显示哪个字符串,更别提还要记录不同的字体,颜色等一系列乱七八糟的东西。</p><p>万幸的是这些都是不必要的, <code>Core Animation</code> 提供了一个 <code>CALayer</code> 的子类 <code>CATextLayer</code> ,它以图层的形 式包含了 <code>UILabel</code> 几乎所有的绘制特性,并且额外提供了一些新的特性。</p><p>同样, <code>CATextLayer</code> 也要比 <code>UILabel</code> 渲染得快得多。很少有人知道在iOS 6及之前的版本, <code>UILabel</code> 其实是通过 <code>WebKit</code> 来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而<br><code>CATextLayer</code> 使用了 <code>Core text</code> ，并且渲染得非常快。</p><p>让我们来尝试用 <code>CATextLayer</code> 来显示一些文字。代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *labelView; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> - (<span class="title">void</span>)<span class="title">viewDidLoad</span></span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//create a text layer</span></span><br><span class="line"><span class="built_in">CATextLayer</span> *textLayer = [<span class="built_in">CATextLayer</span> layer]; </span><br><span class="line">textLayer.frame = <span class="keyword">self</span>.labelView.bounds;</span><br><span class="line">[<span class="keyword">self</span>.labelView.layer addSublayer:textLayer];</span><br><span class="line"></span><br><span class="line"><span class="comment">//set text attributes</span></span><br><span class="line">textLayer.foregroundColor = [<span class="built_in">UIColor</span> blackColor].CGColor; </span><br><span class="line">textLayer.alignmentMode = kCAAlignmentJustified;</span><br><span class="line">textLayer.wrapped = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//choose a font</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//set layer font</span></span><br><span class="line"><span class="built_in">CFStringRef</span> fontName = (__bridge <span class="built_in">CFStringRef</span>)font.fontName; </span><br><span class="line"><span class="built_in">CGFontRef</span> fontRef = <span class="built_in">CGFontCreateWithFontName</span>(fontName); </span><br><span class="line">textLayer.font = fontRef;</span><br><span class="line">textLayer.fontSize = font.pointSize;</span><br><span class="line"><span class="built_in">CGFontRelease</span>(fontRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">//choose some text</span></span><br><span class="line"><span class="built_in">NSString</span> *text = <span class="string">@"Lorem ipsum dolor sit amet, consectetur adipiscing \ </span></span><br><span class="line"><span class="string">elit. Quisque massa arcu, el eifend vel varius in, facilisis pulvinar \ </span></span><br><span class="line"><span class="string">leo. Nunc quis nunc at mauris pharetra condimentum ut ac neq ue. Nunc elementum, \</span></span><br><span class="line"><span class="string">libero ut porttitor dictum, diam odio congue lacus, vel \ </span></span><br><span class="line"><span class="string">fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ </span></span><br><span class="line"><span class="string">lobortis"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set layer text</span></span><br><span class="line">textLayer.string = text; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fcd4gdv906j30hn08hwgv.jpg" alt=""></p><p>如果你仔细看这个文本,你会发现一个奇怪的地方:这些文本有一些像素化了。这是因为并没有以 Retina 的方式渲染,第二章提到了这个 <code>contentScale</code> 属性,用来决定图层内容应该以怎样的分辨率来渲染。<br><code>contentsScale</code> 并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字,我们 就得手动地设置 <code>CATextLayer</code> 的 <code>contentsScale</code> 属性,如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br></pre></td></tr></table></figure><p>这样就解决了这个问题</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fcd4hkwx3bj30ik09etbh.jpg" alt=""></p><p><code>CATextLayer</code> 的 font 属性不是一个 <code>UIFont</code> 类型,而是一个 <code>CFTypeRef</code> 类型。这样可以根据你的具体 需要来决定字体属性应该是用 CGFontRef 类型还是 CTFontRef 类型(Core Text字体)。同时字体大小 也是用 fontSize 属性单独设置的,因为 CTFontRef 和 CGFontRef 并不像UIFont一样包含点大小。这个 例子会告诉你如何将 UIFont 转换成 CGFontRef 。<br>另外, <code>CATextLayer</code> 的 <code>string</code> 属性并不是你想象的 <code>NSString</code> 类型,而是 <code>id</code> 类型。这样你既可以用 <code>NSString</code> 也可以用 <code>NSAttributedString</code> 来指定文本了(注意, <code>NSAttributedString</code> 并不是 <code>NSString</code><br>的子类)。属性化字符串是iOS用来渲染字体风格的机制,它以特定的方式来决定指定范围内的字符串的原 始信息,比如字体,颜色,字重,斜体等。</p><ul><li>摘录自译本：<a href="https://www.gitbook.com/book/zsisme/ios-/details" target="_blank" rel="noopener">《iOS核心动画高级技巧》</a></li><li>原著：<a href="https://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC/ref=sr_1_1?ie=UTF8&amp;qid=1423192842&amp;sr=8-1&amp;keywords=Core+Animation+Advanced+Techniques" target="_blank" rel="noopener">iOS Core Animation: Advanced Techniques</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CATextLayer 性能优化" scheme="https://recherj.github.io/tags/CATextLayer-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks配合Proxifier实现Mac全局科学上网</title>
    <link href="https://recherj.github.io/2017/01/25/Shadowsocks%E9%85%8D%E5%90%88Proxifier%E5%AE%9E%E7%8E%B0Mac%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://recherj.github.io/2017/01/25/Shadowsocks配合Proxifier实现Mac全局科学上网/</id>
    <published>2017-01-25T05:05:43.000Z</published>
    <updated>2018-05-06T10:13:56.725Z</updated>
    
    <content type="html"><![CDATA[<p>前些天写了一篇给git设置全局代理的笔记，使用后发现不是很完美，利用<code>connect</code>接管了git的<code>SSH</code>使得像SourceTree这样的第三方GUI的git管理软件没有办法使用。并且<code>curl</code>、<code>wget</code>等在终端中跑的命令也是不能解决，局限性很大。</p><a id="more"></a><blockquote><h5 id="所以，Proxifier的出现像一个救世主，完美解决了像我这种不能翻墙就会死的人的痛点。"><a href="#所以，Proxifier的出现像一个救世主，完美解决了像我这种不能翻墙就会死的人的痛点。" class="headerlink" title="所以，Proxifier的出现像一个救世主，完美解决了像我这种不能翻墙就会死的人的痛点。"></a>所以，<a href="https://www.proxifier.com/" target="_blank" rel="noopener"><strong>Proxifier</strong></a>的出现像一个救世主，完美解决了像我这种不能翻墙就会死的人的痛点。</h5></blockquote><p>关于Proxifier的使用，我就不在累赘，网上关于proxifier的配置文章实在太多。这里需要感谢一下 <em>@似水无痕</em> 对我的帮助，推荐一下他的简书地址<a href="http://www.jianshu.com/u/30d4b8a17509" target="_blank" rel="noopener">似水无痕的小窝</a>。</p><p>这里需特别说明一点，Proxifier有一个关于DNS的配置</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79jw1fc2t072js4j30fr0d3wge.jpg" alt=""></p><blockquote><p>强烈建议勾选使用<code>Resolve hostnames through proxy</code>，即使用代理服务器DNS解析。</p></blockquote><p>系统default是上一个选项，即使用ISP分配给你的DNS。众所周知，国内网络有墙，如使用这种被污染的DNS是无法请求你需要的网址，所以建议使用你ss里的代理服务器DNS。</p><p>关于Proxifier配置使用的详细讲解，推荐 <em>@似水无痕</em> 同学的一篇博文</p><p><a href="https://www.zybuluo.com/yiranphp/note/611721" target="_blank" rel="noopener">解决 mac （windows）终端上代理的难题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天写了一篇给git设置全局代理的笔记，使用后发现不是很完美，利用&lt;code&gt;connect&lt;/code&gt;接管了git的&lt;code&gt;SSH&lt;/code&gt;使得像SourceTree这样的第三方GUI的git管理软件没有办法使用。并且&lt;code&gt;curl&lt;/code&gt;、&lt;code&gt;wget&lt;/code&gt;等在终端中跑的命令也是不能解决，局限性很大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ss proxifier 科学上网" scheme="https://recherj.github.io/tags/ss-proxifier-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>配合Shadowsocks为git配置SSH全局代理突破GFW</title>
    <link href="https://recherj.github.io/2017/01/17/%E9%85%8D%E5%90%88Shadowsocks%E4%B8%BAgit%E9%85%8D%E7%BD%AESSH%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%AA%81%E7%A0%B4GFW/"/>
    <id>https://recherj.github.io/2017/01/17/配合Shadowsocks为git配置SSH全局代理突破GFW/</id>
    <published>2017-01-17T02:27:52.000Z</published>
    <updated>2018-05-06T06:43:05.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><hr><ul><li>2017-01-17 初稿</li><li>2017-01-18 用 ssh:// 协议全局替换 https:// 协议</li></ul><hr><p>由于国内的特殊的网络环境，在某些特殊地方GFW更加凶残，github和国内的CSDN博客等网站居然都是封堵的，这让我们这些只想安静的写两行代码与世界的程序员交流(clone第三方框架)的美好愿望都无法实现。</p><a id="more"></a><p>由于对github的限制，让在terminal中的一些命令异常难执行。国内的程序员在科学上网也是<em>八仙过海，各显神通</em>。几种主流的何学上网手段：</p><ul><li>VPN</li><li>shadowsock</li><li>lantern</li></ul><p>先说VPN，本想买个VPN一劳永逸，免得在翻墙上浪费太多时间，结果经过测试，发现VPN在这种特殊地方管控更加严格，连他们的自己都回复说由于国家对你们网络管制太严格，VPN无法稳定的使用。所以VPN这条路是行不通。国外的VPN也许可以，但由于价位太高，出于成本考虑我没有进行测试，但也估计很难达到稳定的效果。</p><p>ss的稳定家喻户晓，我也长期再用。但局限性大家都知道，这种智能代理浏览器中的http和https请求，对于在一些终端中要跑的命令还是无法解决。</p><p>lantern相同，如果你只是想上上YouTube或Google等浏览一下网页，我想免费的lantern已经足够用了。</p><p>写代码免不了要与git打交道，中断不通相当于自断一臂。</p><blockquote><p>为了解决这个问题网上各种搜索查阅，花了2天时间，目前已经可以实现<code>SSH</code>方式自由的访问github</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>shadowsocks一枚</li><li>connect</li><li>系统已安装git</li></ul><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p>ss建议直接购买，网上很多，不要自己搭建因为付费的速度非常快，个人香港节点全天看YouTube1080p视频无压力。</p><p>首先，ss直接全局模式</p><p><a href="https://bitbucket.org/gotoh/connect" target="_blank" rel="noopener">connect</a>直接利用sourcetree软件clone到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> connect</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 然后将编译得到的文件connect拷贝到bin目录</span></span><br><span class="line">cp connect /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>修改ssh的配置文件(没有就新建一个)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局</span></span><br><span class="line">ProxyCommand connect -S 127.0.0.1:1080 %h %p  </span><br><span class="line"><span class="comment"># 只为特定域名设定</span></span><br><span class="line">Host github.com  </span><br><span class="line">        ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure><p>建议直接使用全局模式，直接<code>#</code>注释针对个别域名的代理</p><blockquote><p>-S 表示SSH，-H表示http或https</p></blockquote><p>这样在命令行中就可以使用SSH的方式去访问github了</p><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fbtg3f8wnvj30py03tt9y.jpg" alt="效果图"></p><p>-H即用https的方式还是无法正常使用</p><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fbtg8cqamej30oq06ntb4.jpg" alt=""></p><p>在执行<code>pod install</code>时发现默认走https方式安装第三方依赖，<br>后来各种搜索，有说给git设置socks5代理来解决的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br></pre></td></tr></table></figure><p>这样就会在<code>~/.gitconfig</code>文件中看到这样的一个代理</p><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fbtgcsaa9ij30cg025dfz.jpg" alt=""></p><p>但貌似还是不行</p><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fbtgdn0a26j30oq01qgm7.jpg" alt=""></p><p>折腾了很久，最后苦于无果只得利用修改hosts的方式来突破封锁了。。</p><p>直接将github.com的ip配置在<code>/etc/hosts</code>文件中</p><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbtggsjjyfj30ou070763.jpg" alt=""></p><p>暂时是能用了，但这种方式在极端严苛的环境下不知道能坚挺几天，但愿不要被请去喝茶..</p><hr><p>一直无法解决terminal中https协议的访问，今天查阅资料，在网上看到rewrite git的URL来解决,在<code>~/.gitconfig</code>配置文件中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;ssh://git@github.com/&quot;]</span><br><span class="line">    insteadOf = https://github.com/</span><br></pre></td></tr></table></figure><p>利用<code>ssh:</code>协议全局替代<code>https</code>协议，测试可用，暂时先这样折中解决吧</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://moonagic.com/setup-git-proxy-on-mac/" target="_blank" rel="noopener">在Mac上为git配置代理</a><br></li><li><a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="noopener">git 设置和取消代理</a><br></li><li><a href="http://blog.csdn.net/wuquan0625/article/details/47401235" target="_blank" rel="noopener">pod install速度慢的终极解决方案</a><br></li><li><a href="https://segmentfault.com/q/1010000000118837" target="_blank" rel="noopener">如何为 Git 设置代理？</a><br></li><li><a href="https://blog.fazero.me/2015/07/11/%E7%94%A8shadowsocks%E5%8A%A0%E9%80%9Fgit-clone/" target="_blank" rel="noopener">用shadowsocks加速git clone</a><br></li><li><a href="http://leolovenet.com/blog/2014/05/28/git-and-proxy/" target="_blank" rel="noopener">配置git使用proxy</a><br></li><li><a href="https://github.com/npm/npm/issues/10037" target="_blank" rel="noopener">Failed to connect to github.com port 443: connection refused </a><br></li><li><a href="http://stackoverflow.com/questions/29333319/failed-to-connect-to-github-443" target="_blank" rel="noopener">Failed to connect to github 443</a><br></li><li><a href="https://github.com/CocoaPods/CocoaPods/issues/6312" target="_blank" rel="noopener">help! cannot load such file – nanaimo</a><br></li><li><a href="https://github.com/carlhuda/janus/issues/593" target="_blank" rel="noopener">OSX - Server aborts SSL handshake while cloning</a> <br></li><li><a href="http://stackoverflow.com/questions/36936678/git-and-server-aborted-the-ssl-handshake-errors" target="_blank" rel="noopener">git and “Server aborted the SSL handshake” errors</a><br></li><li><a href="https://github.com/CocoaPods/CocoaPods/issues/2724" target="_blank" rel="noopener">“pod install” failson 0.34.4 with source in Podfile</a><br></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;更新说明&quot;&gt;&lt;a href=&quot;#更新说明&quot; class=&quot;headerlink&quot; title=&quot;更新说明&quot;&gt;&lt;/a&gt;更新说明&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;2017-01-17 初稿&lt;/li&gt;
&lt;li&gt;2017-01-18 用 ssh:// 协议全局替换 https:// 协议&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;由于国内的特殊的网络环境，在某些特殊地方GFW更加凶残，github和国内的CSDN博客等网站居然都是封堵的，这让我们这些只想安静的写两行代码与世界的程序员交流(clone第三方框架)的美好愿望都无法实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ss github.com 科学上网" scheme="https://recherj.github.io/tags/ss-github-com-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>App打包时遇大量警告解决办法</title>
    <link href="https://recherj.github.io/2016/05/05/App%E6%89%93%E5%8C%85%E6%97%B6%E9%81%87%E5%A4%A7%E9%87%8F%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://recherj.github.io/2016/05/05/App打包时遇大量警告解决办法/</id>
    <published>2016-05-05T01:44:33.000Z</published>
    <updated>2018-05-06T10:13:17.689Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在对App进行最后一次小修小布后，准备进行第一个版本的打包上架，在真机运行和调试时都没有问题，但是当<code>Archive</code>时一下呼呼出现了89个警告，我想当时我的表情应该是这样的<br><a id="more"></a><br><img src="/img/download.png" alt=""></p><p>这么多警告，能上架吗？？？ ！！<br><br>几乎全是类似于这样的警告 <code>xxxx.pch No such file or directory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: /var/folders/_j/hqhnz9xd2qv_39dd1vdmw1nc0000gn/C/org.llvm.clang.tarekskr/ModuleCache/2YCOBXU93NY4O/UIKit-1MCEWB5GAZIR1.pcm: No such file or directory</span><br></pre></td></tr></table></figure><p>其实之前也遇到过，但是当时没管，想的反正又不是报错，程序能跑不就完了，但是一想到苹果那严苛的审核机制，万一遇上个心情不好的，拒绝后我再提上去，一个月过去了。。 想到这，我还是不要挑战苹果的底线，老老实实改警告</p><p><img src="/img/url.gif" alt=""></p><p>于是各种Google呀，各种查，stackoverflow上和Apple Developer Forums遇到过这个问题的人倒也挺多，大概看了一下，很多人说这是Xcode7 beta版的问题，没有什么好的解决办法，也有人说这是编译时链接问题，想办法绕过就可以了，于是我参照了别人的解决方案修改了一下几个编译链接的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Precompile Prefix (GCC_PRECOMPILE_PREFIX_HEADER) = NO</span><br><span class="line">- Debug Information Format (DEBUG_INFORMATION_FORMAT) = DWARF with dSYM</span><br><span class="line">- Enabled Modules (C and Objective-C) (CLANG_ENABLE_MODULES) = NO</span><br></pre></td></tr></table></figure></p><p><a href="https://forums.developer.apple.com/thread/17921" target="_blank" rel="noopener">Lots of warnings when building with Xcode 7 with 3rd party libraries</a><br><br><a href="https://forums.developer.apple.com/message/47932#47932" target="_blank" rel="noopener">Warnings creating dSYM in Xcode beta 6</a><br><br><a href="http://sensiblecocoa.com/community/topic/2344-warnings-with-stv-500-and-xcode-7-beta-5/#entry12829" target="_blank" rel="noopener">Warnings with STV 5.0.0 and Xcode 7 beta 5</a></p><p>然而并没什么乱用。。</p><p>后来我怀疑可能是当时引入了一个pch导致，因为当时我的pch文件在工程中是全路径引入，即<code>/Users/liuyonggang/Documents/Guitar/GuitarTeach/GuitarTeach/Classes/Others/PrefixHeader.pch</code></p><p>会不会是这个在打包后，就找不到文件里面的链接地址了呢？ 反正不管那么多，先改了再说，我记得之前学习时看老师的代码中pch文件路径是截止到工程路径位置，不写全路径。于是我将路径改为<code>GuitarTeach/Classes/Others/PrefixHeader.pch</code>，并将<code>Precompile Prefix Header</code>设置为NO，CMD+B 哎呦通过了！<br>然后再打包时就一下只剩4个警告了，看到从89个警告变为4个，心里那是一个酸爽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在对App进行最后一次小修小布后，准备进行第一个版本的打包上架，在真机运行和调试时都没有问题，但是当&lt;code&gt;Archive&lt;/code&gt;时一下呼呼出现了89个警告，我想当时我的表情应该是这样的&lt;br&gt;
    
    </summary>
    
    
      <category term="fix bug" scheme="https://recherj.github.io/tags/fix-bug/"/>
    
  </entry>
  
  <entry>
    <title>dyld: Library not loaded: /System/Library/Frameworks/ModelIO.framework/XXXX问题解决</title>
    <link href="https://recherj.github.io/2016/05/05/dyld-Library-not-loaded-System-Library-Frameworks-ModelIO-framework-XXXX%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://recherj.github.io/2016/05/05/dyld-Library-not-loaded-System-Library-Frameworks-ModelIO-framework-XXXX问题解决/</id>
    <published>2016-05-05T01:28:46.000Z</published>
    <updated>2018-05-06T10:13:26.878Z</updated>
    
    <content type="html"><![CDATA[<p>29号用朋友4s（iOS 8.4.1）真机调试时，编译时没问题，运行时程序直接奔溃，控制台打印出现了这样一个问题<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: /System/Library/Frameworks/ModelIO.framework/ModelIO</span><br><span class="line">  Referenced from: /var/mobile/Applications/。。。。。</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure></p><p>后来Google了一下，网上也有人遇到过，是因为导入的框架引起的，将<code>ModelIO.framework</code>这个框架的status改为可选的即可(<strong>Optional</strong>)</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.csdn.net/xiaohei5188/article/details/12655421" target="_blank" rel="noopener">xcode解决问题dyld: Library not loaded(AdSupport.framework)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;29号用朋友4s（iOS 8.4.1）真机调试时，编译时没问题，运行时程序直接奔溃，控制台打印出现了这样一个问题&lt;br&gt;
    
    </summary>
    
    
      <category term="fix bug" scheme="https://recherj.github.io/tags/fix-bug/"/>
    
  </entry>
  
  <entry>
    <title>根据不同控制器自动切换横竖屏</title>
    <link href="https://recherj.github.io/2016/04/21/%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%A8%AA%E7%AB%96%E5%B1%8F/"/>
    <id>https://recherj.github.io/2016/04/21/根据不同控制器自动切换横竖屏/</id>
    <published>2016-04-21T14:51:27.000Z</published>
    <updated>2018-05-06T10:15:28.297Z</updated>
    
    <content type="html"><![CDATA[<p>准备制作自己的第一款App,但是遇到一个技术上问题：</p><blockquote><p><strong>如何在当前控制器modal出下一个控制器时自动将屏幕切换成横屏模式</strong>。</p></blockquote><a id="more"></a><h3 id="技术点："><a href="#技术点：" class="headerlink" title="技术点："></a>技术点：<br></h3><ul><li><p>App是否支持横竖屏由plist中的配置文件决定，这个设置在PROJECT-&gt;Deployment Info中设置<br><img src="/img/横竖屏.png" alt="横竖屏"></p></li><li><p>一个ViewController是否支持横竖屏由这个函数控制<code>supportedInterfaceOrientations</code><br></p></li><li><p>如果当前嵌套了<code>TabBarController</code>和<code>NavigationController</code>之后情况和直接使用<code>UIViewController</code>是不一样的，这里<em>岁寒</em>说的很好</p><blockquote><blockquote><p>跟 shouldAutorotate() 不同，判断是否应该改变 APP 屏幕方向并不会检测当前显示的 View Controller 的属性，而是去检测根 View Controller 的属性，所以我们要从 TabBarController 一路获取到当前 View Controller。</p></blockquote></blockquote></li><li><p>当modal出来的控制嵌套了导航控制器时，需要对导航控制器重写<code>supportedInterfaceOrientations</code>方法，来控制其子控制器。</p></li><li>当第一个控制器modal出第二个控制器，设置其屏幕模式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)playClick &#123;</span><br><span class="line">    VideoViewController *vc = [[VideoViewController alloc] init];</span><br><span class="line">    YGNavigationController *nav = [[YGNavigationController alloc] initWithRootViewController:vc];</span><br><span class="line">    nav.orientation = VideoOrientationLandscapeLeft;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController presentViewController:nav animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为导航控制器定义一个枚举，表示其横竖屏</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    VideoOrientationLandscapeLeft = <span class="number">1</span>,</span><br><span class="line">    VideoOrientationPortrait = <span class="number">2</span></span><br><span class="line">&#125; VideoOrientation;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YGNavigationController</span> : <span class="title">UINavigationController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) VideoOrientation orientation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样第一个控制才能拿到这个属性，进行修改。</p><ul><li>导航控制其中重写<code>supportedInterfaceOrientations</code>方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.orientation == VideoOrientationLandscapeLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前控制器是否是横屏模式</p><ul><li>在<code>tabBarController</code>中将所有子控制锁定为竖屏模式，只有在需要横屏的控制器中才设置为横屏模式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  锁死所有自控制器为竖屏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不管用户是否锁定为锁屏，都可以自由的切换为想要的横屏模式了。非常简单~<br><img src="/img/横竖屏效果图.gif" alt="效果图"></p><p>这里非常感谢，<em>岁寒</em>的技术博客。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://lvwenhan.com/ios/458.html" target="_blank" rel="noopener">如何用代码控制以不同屏幕方向打开新页面【iOS】</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备制作自己的第一款App,但是遇到一个技术上问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如何在当前控制器modal出下一个控制器时自动将屏幕切换成横屏模式&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac下利用github和Hexo搭建个人博客（二）</title>
    <link href="https://recherj.github.io/2016/04/18/Mac%E4%B8%8B%E5%88%A9%E7%94%A8github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://recherj.github.io/2016/04/18/Mac下利用github和Hexo搭建个人博客（二）/</id>
    <published>2016-04-18T08:32:46.000Z</published>
    <updated>2018-05-06T10:13:38.492Z</updated>
    
    <content type="html"><![CDATA[<p><em>补上4月9号要写的后续搭建博客</em><br><a id="more"></a><br>利用Google搜索关键字<strong>“Hexo+github+个人博客”</strong>可以足足搜出4页之多，大家已经非常详尽的写了如果利用github和Hexo搭建个人的博客。我就不在阐述，Hexo上也有非常详尽的教程。这里只是总结一下基本的要点，和注意事项，记录一下帮助我以后如果重装系统或更换电脑重新搭建使用。</p><p>首先，默认已经安装了Node。</p><h3 id="安装Hexo："><a href="#安装Hexo：" class="headerlink" title="安装Hexo："></a>安装Hexo：</h3><ul><li>现在安装Hexo到本机上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></li></ul><p>执行上面的命令时最好开着VPN，因为不科学上上网可能导致部分插件安装不完整</p><ul><li><p>然后在需要创建博客的目录下面，输入一下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>这时，在浏览器输入<code>http://0.0.0.0:4000/</code> 就可以看到本地静态的博客样式了，里面默认会有一篇<code>hello world</code></p></li></ul><h3 id="设置github"><a href="#设置github" class="headerlink" title="设置github"></a>设置github</h3><ul><li>默认已经拥有github账号。</li><li>在github上新建一个仓库以<code>yourname.github.io</code>命名。</li><li><p>在本地配置用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name yourname</span><br><span class="line">git config --global user.email youremail</span><br></pre></td></tr></table></figure></li><li><p>查看当前所有的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li></ul><p>cd进blog目录下将github上的仓库<code>clone</code>下来</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><p>cd进blog目录下，里面有个<code>_config.yml</code>配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure></p><p>里面有个<code>deploy</code>字段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repository: https://github.com/yourname/yourname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p><p>注意：冒号后面都要空一格</p><p>新建博客<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"博客名称"</span></span><br></pre></td></tr></table></figure></p><p>清除缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>部署<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate -d</span><br></pre></td></tr></table></figure></p><p>###写在最后</p><p>建议利用<code>https</code>提交发布博客内容，之前使用的是SSH来发布，但是由于我朝网络的问题，经常会出现连接不上的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to host github.com port 22: Operation timed out</span><br></pre></td></tr></table></figure><p><code>StackOverflow</code>上有人说可以把SSH的端口号改为443走https，但我觉得最好的办法还是使用https部署</p><p><a href="http://stackoverflow.com/questions/15589682/ssh-connect-to-host-github-com-port-22-connection-timed-out" target="_blank" rel="noopener">ssh: connect to host github.com port 22: Connection timed out</a><br><a href="https://help.github.com/articles/using-ssh-over-the-https-port/" target="_blank" rel="noopener">Using SSH over the HTTPS port</a></p><p>修改的方式在<code>_config.yml</code>配置文件中有一个deploy设置。同时，也要修改github上仓库的提交方式。</p><p>参考链接：<br><a href="http://www.jianshu.com/p/821fe67e712b" target="_blank" rel="noopener">简书-Hexo搭建静态个人博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;补上4月9号要写的后续搭建博客&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo个人博客" scheme="https://recherj.github.io/tags/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>OC下runtime获取类私有成员属性</title>
    <link href="https://recherj.github.io/2016/04/18/OC%E4%B8%8Bruntime%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/"/>
    <id>https://recherj.github.io/2016/04/18/OC下runtime获取类私有成员属性/</id>
    <published>2016-04-18T03:36:36.000Z</published>
    <updated>2018-05-06T10:13:48.687Z</updated>
    
    <content type="html"><![CDATA[<p>苹果的runtime运行机制还是非常强大的，掌握runtime对开发帮助是如虎添翼。因为有些类的私有成员属性是不暴漏在外供开发者使用的，但是有时，如果我们知道了这些属性对开发来说事半功倍，省去很多麻烦。</p><a id="more"></a><p>下面介绍一个runtime中的C语言函数，可以找出这些藏在类中的私有成员属性。使用方法也很简单，首先导入头文件<code>#import &quot;objc/runtime.h&quot;</code>,这样就可以敲出下面这个方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p><p>两个参数：第一个传入你想获取的类，第二个传入一个整型的总数count的地址，它会返回这个总数给你。<br>这个函数返回的是一个Ivar类型的指针对象，该指针指向每一个属性的地址，其实就是一个数组，遍历这个数组，就可以取出所有的私有成员变量了。<br><strong>注意点</strong>：该列表返回的属性中，只有本来的私有成员属性，不包含继承父类的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    <span class="comment">//获取属性名</span></span><br><span class="line">    <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ivarName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到私有的成员属性后，就可以利用KVC来取出对应的值，非常方便。</p><p>例如，可以利用这个方法在系统手势的基础上，增加一个自定义的返回手势</p><p>系统的返回手势，只有在靠近左边滑动时才会有返回效果，如果我们希望在中间向右滑动也有返回效果的话，我们可以自己添加一个手势，将其添加到导航控制的View上，调用系统自带的target选择子，来实现该功能</p><p>首先，禁用系统自带的滑动返回手势<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure></p><p>新建一个手势，将其添加到导航控制器View上<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure></p><p>这里target对象就是利用KVC模式取出的target</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *targets= [<span class="keyword">self</span>.interactivePopGestureRecognizer valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line"><span class="keyword">id</span> objc = [targets firstObject];</span><br><span class="line"><span class="keyword">id</span> target = [objc valueForKeyPath:<span class="string">@"_target"</span>];</span><br></pre></td></tr></table></figure><p>这样即使滑动中间也会有返回手势了，并且与系统自带的靠边返回不冲突。但是，如果当前的导航控制的栈顶控制器是自身的话，我们其实是需要将这个手势禁用的。因为，当前栈中已经没有需要出栈的控制器了。<br><code>UIGestureRecognizerDelegate</code>代理方法中有一个监听手势是否可用的方法，返回YES时手势可用。<br>给刚才自己添加的pan手势设置代理<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pan.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure></p><p>遵守<code>UIGestureRecognizerDelegate</code>协议<br>当栈顶控制不等于自己时返回YES，如果是自己就返回NO,禁用自定义的手势</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.topViewController != [<span class="keyword">self</span>.viewControllers firstObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就给利用运行时机制和系统自带的手势识别给系统增加了一个我们自定义的手势。</p><p><img src="/img/返回手势.gif" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果的runtime运行机制还是非常强大的，掌握runtime对开发帮助是如虎添翼。因为有些类的私有成员属性是不暴漏在外供开发者使用的，但是有时，如果我们知道了这些属性对开发来说事半功倍，省去很多麻烦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linker command failed with exit code 1 (use -vto see invocation)原因和解决</title>
    <link href="https://recherj.github.io/2016/04/17/linker-command-failed-with-exit-code-1-use-vto-see-invocation-%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>https://recherj.github.io/2016/04/17/linker-command-failed-with-exit-code-1-use-vto-see-invocation-原因和解决/</id>
    <published>2016-04-17T10:22:27.000Z</published>
    <updated>2018-05-06T10:13:32.676Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写代码是遇到一个问题，编译时通不过，报“linker command failed with exit code 1 (use -vto see invocation)”错误，其实之前也遇到过，但是不理明白怎么去解决，就绕开了。。今天Google了一下说是可能是因为相同的.m文件造成的。<br><a id="more"></a><br><a href="http://www.cnblogs.com/Wild-orangutans/p/4223652.html" target="_blank" rel="noopener">参考链接</a></p><p>但是我这没有同名的两个类，怎么会存在这样的问题呢。但是貌似理解了，应该是两个文件中定义了相同内容的东西，导致编译时生成了相同的.o文件导致。<br>检查发现时因为在appDelegate.m文件中加入了一个通知，同时在发送通知的类中也加入了相同的通知声明<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> YGNewFeatureStartBtnClickNotification = <span class="string">@"YGNewFeatureStartBtnClickNotification"</span>;</span><br></pre></td></tr></table></figure></p><p>于是将这段代码加入到了pch文件中声明成全局的，删掉了appDelegate中和发通知类中的相同申明，但是编译还是不通过。</p><p>提示还是<code>appDelagate.o</code>文件和<code>YGNewFeatureController.o</code>文件有冲突，可能是直接将这个定义加入pch中不行，从新建立了一个继承自NSObject的类，专门用来申明全局使用到的常量<br>.h中加入</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  切换根控制器通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> YGNewFeatureStartBtnClickNotification;</span><br></pre></td></tr></table></figure><p>.m中具体实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> YGNewFeatureStartBtnClickNotification = <span class="string">@"YGNewFeatureStartBtnClickNotification"</span>;</span><br></pre></td></tr></table></figure><p>搞定~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写代码是遇到一个问题，编译时通不过，报“linker command failed with exit code 1 (use -vto see invocation)”错误，其实之前也遇到过，但是不理明白怎么去解决，就绕开了。。今天Google了一下说是可能是因为相同的.m文件造成的。&lt;br&gt;
    
    </summary>
    
    
      <category term="报错解决" scheme="https://recherj.github.io/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>《不是每个故事都有解决》-读书笔记</title>
    <link href="https://recherj.github.io/2016/04/16/%E3%80%8A%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E6%95%85%E4%BA%8B%E9%83%BD%E6%9C%89%E7%BB%93%E5%B1%80%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://recherj.github.io/2016/04/16/《不是每个故事都有结局》-读书笔记/</id>
    <published>2016-04-16T13:07:23.000Z</published>
    <updated>2018-05-06T10:12:59.833Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本情感故事类的书，一本闲书。<br><a id="more"></a><br><img src="/img/不是每个故事都有结局.png" alt="不是每个故事都有结局"></p><p><a href="https://www.amazon.cn/%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E6%95%85%E4%BA%8B%E9%83%BD%E6%9C%89%E7%BB%93%E5%B1%80-%E7%8E%8B%E8%B1%96/dp/B01D9L2R8E/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1460812224&amp;sr=1-1&amp;keywords=%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E6%95%85%E4%BA%8B%E9%83%BD%E6%9C%89%E7%BB%93%E5%B1%80" target="_blank" rel="noopener">亚马逊购买链接</a></p><p>作者<strong>王豕</strong>，是我在知乎上认识的一个大V，此人有留学经历，御姐一枚，聪颖漂亮，才华横溢，又会撩汉。比较欣赏。在学习新浪微博项目时顺便关注了她，然后得知其花了一年时间写了一本书，个人首部作品，在微博上卖的拼命，不惜爆照来换取粉丝买书，也是感叹太拼了，哈哈哈哈哈。就决定买来读一读。</p><p>前前后后零散的花了2天时间读完，一本情感类书籍，每一节是一个故事。通俗的白话，没有深奥的哲理意义，作者借用书中主人公的身份讲述她的留学经历和生活经历，以及对感情等个人价值观。</p><p>有别于我听过、读过或看过的其他女作家，王豕个人这部作品，没有矫情的文字，缠绵的爱情桥段或错综复杂的情感纠葛，冷静、平和的以一个旁观者的身份讲述了身边一起留学的朋友和自己的情感经历。看着不酸不腻，处处彰显着一个现代成熟的独立女性个人魅力。</p><blockquote><p>故事的主人公于一，一个从小叛逆与众不同的女孩子，读完大学后决定留学法国，在国外合租结识了一起求学的柯米和董荷蔓，作者以于一的身份讲述了她们几个的爱情观和现实经历，同时表达了作者对感情，人生的一些看法。</p></blockquote><p>里面有几处作者的人生观独白，还是非常不错。由于来了朋友，仓促将书籍借于他，没来的及记录下来。简单的写写，没有什么太大的感触，毕竟已经不是情窦初开的少年了，也没那么多感慨，买的目的就是用来写代码累了拿来休息休息，另外看作者卖书也是蛮拼。</p><p>如果闲着，可以买来一读，还是可以看看，以一个女性的角度去了解一下女性对爱情价值观。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一本情感故事类的书，一本闲书。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://recherj.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-2.0》读书笔记一</title>
    <link href="https://recherj.github.io/2016/04/12/%E3%80%8AEffective-Objective-2-0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://recherj.github.io/2016/04/12/《Effective-Objective-2-0》读书笔记一/</id>
    <published>2016-04-12T15:18:10.000Z</published>
    <updated>2018-05-06T06:42:44.945Z</updated>
    
    <content type="html"><![CDATA[<p>这本书也是我之前在一篇别人推荐的移动开发必读的书单中看到的，这本被重点推荐。然后上亚马逊看了一下大家的评价，还不错，就决定买了，不过就是挺贵的，69软妹。。 但我觉得挺值得，非常值得一看。</p><a id="more"></a><p>与其他的iOS开发书籍翻译官方文档不同，这个书的作者是一个位有着非常丰富开发经验的老外，从事iOS和Mac开发多年。积累下的52条纯干货，真的很干。。看完一遍，其实很多还是没有什么太深的体会，网上也是建议大家有2到3年开发经验的读者阅读，书中的知识点覆盖非常全面，基本把所有OC开发中可能遇到的坑都总结出来了。</p><p>下面简单写一些我看完后的认识：</p><h2 id="熟悉Objective-c"><a href="#熟悉Objective-c" class="headerlink" title="熟悉Objective-c"></a>熟悉Objective-c</h2><ul><li>知道了OC是一门消息语言，在运行期才会检查对象的类型。</li><li>除非确有必要，不要在头文件中导入其他类的头文件，降低耦合性，采用向前声明来引入其他类，即<code>@class 类名</code>的方式。</li><li>作者推荐使用字面量语法来创建字符串、数组、数值、字典。如果值一旦为nil，就会奔溃，方便调试。</li><li>头文件中声明的全局常量有<code>EXTERN</code>来声明，并用该类的类名做前缀。</li></ul><h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><ul><li>类族模式可以把实现细节隐藏在一套简单的公共接口后面</li><li>给某对象“发送消息”也就相当于在该对象上“调用方法”。</li><li>对象会把无法解读的消息转发给其他对象来处理，如果经过一层层转发后还是没有对象能处理，那么就抛出异常提示，程序奔溃。</li><li>方法调配也称“黑魔法”，这个技术是在运行期将两个方法互换调用，一般可以给那些不知道具体实现的方法增加日志记录功能，一般在调试时使用，但是也要慎用，不然代码将非常难读懂。</li><li>每个OC对象实例都是指向某块内存数据的指针。</li><li><code>isMemberOfClass:</code>可以判断出对象是否为某个特定类的实例，<code>isKindOfClass:</code>可以判断出独享是否为某类或派生类的实例。</li><li>某个对象可能会把收到的所有选择子转发给另外一个对象，这样的对象叫代理<code>proxy</code>，此对象均以NSProxy为根类；</li></ul><h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><ul><li>给类名或方法名添加前缀，避免与系统的或其他的冲突。</li><li>如果父类的初始化方法不试用于子类，那么应该复写这个父类的方法，并在其中抛出异常。</li><li><code>debugDescription</code>方法是开发者在调试器中以控制台命令打印对象时才调用。</li><li>对外公布的成员属性，应设置成只读<code>readonly</code>，不让外界随意修改变量，保证一些封装的功能能正常运行。</li><li>在公共接口中声明的属性，可以在分类中重新声明为可读可写。</li><li>命名一定要规范，简洁、易理解，可以为一些私有方法增加前缀与共有方法加以区分。</li><li>在可变对象上调用<code>copy</code>方法会返回另外一个不可变类的实例。</li><li>若想让自己所写的对象具备拷贝功能，则需实现<code>NSCopying</code>协议。</li></ul><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><ul><li>委托模式（代理模式）为对象提供一套接口，使其可由此将相关事件告知其他对象</li><li>当某个对象需要从另外一个对象获取数据时，可以使用委托模式，在这种情况下，该模式也称“数据源协议”。</li><li>善于利用分类，将实现代码划分成易于管理的各小块。</li><li>将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。如果类中本来就有此方法，分类又实现了一次，就会覆盖原来的方法，多次覆盖的结果以最后一次为准。</li><li>给第三方类中添加分类时，应该给名称和方法都加上自己的前缀。</li><li>把封装数据所用的全部属性都定义在主接口中，不要在分类中增加属性，但是可以增加方法。</li><li>协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>引用计数机制通过可以递增或递减计数器来管理内存，对象创建好后，其保留计数器为1，若引用一次，会+1，当计数器降为0时，对象即被销毁。</li><li>ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”和“释放”操作。</li><li>ARC只负责管理Objective-C对象的内存，<code>CoreFoundation</code>对象不管理</li><li>在<code>dealloc</code>方法中取消订阅的“键值观察（KVO）”或<code>NSNotificationCenter</code>通知。</li><li><code>block</code>块中一定要用弱引用，不然会产生保留环，对象不能被销毁。</li><li>合理利用自动释放池，可以降低程序的内存峰值。</li><li>系统在回收对象时不会将其真的回收，而是把它转化成僵尸对象。通过环境变量<code>NSZombieEnabled</code>可开启此功能。</li><li>不要使用<code>retainCount</code>，任何时间点上的“绝对保留计数”都无法反正生命期的全貌，所以这个保留计数其实是不准确的。</li></ul><h2 id="块与大中枢派发"><a href="#块与大中枢派发" class="headerlink" title="块与大中枢派发"></a>块与大中枢派发</h2><ul><li>在块中的所有变量都可以被其捕获，默认情况下，被块捕获的变量是不可以在块里修改的，声明变量时在前面加上<code>__block</code>修饰符，这样就可以在块中修改了。</li><li>建议为所有的块都定义别名，这样可以令块更加易读，更重要的是，如果一处块的参数变量修改了，那么不定义的话，其他用到该块的地方都要修改，而创建了<code>typedef</code>的则不用，扩展性更好</li><li>块可以使业务逻辑更加紧凑，联系性更好。</li><li>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，这样不会阻塞执行异步派发线程。</li><li>通过<code>dispatch_once</code>函数执行只需要执行一次的线程代码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书也是我之前在一篇别人推荐的移动开发必读的书单中看到的，这本被重点推荐。然后上亚马逊看了一下大家的评价，还不错，就决定买了，不过就是挺贵的，69软妹。。 但我觉得挺值得，非常值得一看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://recherj.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>手势识别器几个重要知识点</title>
    <link href="https://recherj.github.io/2016/04/11/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://recherj.github.io/2016/04/11/手势识别器几个重要知识点/</id>
    <published>2016-04-11T14:21:53.000Z</published>
    <updated>2018-05-06T10:14:53.461Z</updated>
    
    <content type="html"><![CDATA[<p>今天复习了一下手势识别器，<code>UIGestureRecognizer</code>类<br>该类中包含以下几个子类</p><a id="more"></a><ul><li>UITapGestureRecognizer(敲击)</li><li>UIPinchGestureRecognizer(捏合，用于缩放)</li><li>UIPanGestureRecognizer(拖拽)</li><li>UISwipeGestureRecognizer(轻扫)</li><li>UIRotationGestureRecognizer(旋转)</li><li>UILongPressGestureRecognizer(长按)</li></ul><h3 id="UISwipeGestureRecognizer"><a href="#UISwipeGestureRecognizer" class="headerlink" title="UISwipeGestureRecognizer"></a>UISwipeGestureRecognizer</h3><p>其中轻扫手势有一个扫动方向，<code>direction</code>属性，支持4个方向的扫动，是一个枚举。不设置默认是向右扫动。如果想支持多个方向的扫动，需要给该控件添加多个手势即可。</p><h3 id="UIPanGestureRecognizer"><a href="#UIPanGestureRecognizer" class="headerlink" title="UIPanGestureRecognizer"></a>UIPanGestureRecognizer</h3><ul><li><code>- translationInView:</code>方法返回一个在该控件上移动的点。所以可以改变该控件的<code>transform</code>值来实现拖拽的效果，实现代码如下：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取移动点</span></span><br><span class="line"><span class="built_in">CGPoint</span> transP = [pan translationInView:<span class="keyword">self</span>.imageView];</span><br><span class="line"><span class="keyword">self</span>.imageView.transform = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.imageView.transform, transP.x, transP.y);</span><br><span class="line"><span class="comment">// 复位</span></span><br><span class="line">[pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span>.imageView];</span><br></pre></td></tr></table></figure><ul><li>改变了控件的<code>transform</code>的属性后一定要将移动点置零，不然会有一个叠加效果，会在当前的<code>transform</code>基础上继续叠加，类似于一个加速度的概念。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span>.imageView];</span><br></pre></td></tr></table></figure><h3 id="UIRotationGestureRecognizer"><a href="#UIRotationGestureRecognizer" class="headerlink" title="UIRotationGestureRecognizer"></a>UIRotationGestureRecognizer</h3><ul><li>旋转手势有一个旋转角度的属性<code>rotation</code>属性，改变这个值可完成旋转的效果</li><li>但同样，当改变控件的<code>transform</code>属性后也是要清空这个<code>rotation</code>，性质类似于拖拽手势的<code>translation</code>。</li></ul><p>此外，需要支持多个手势复合识别，需要实现<code>UIGestureRecognizerDelegate</code>代理协议中的一个<code>- (BOOL)gestureRecognizer: shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>方法，返回Yes，代表支持多个手势识别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天复习了一下手势识别器，&lt;code&gt;UIGestureRecognizer&lt;/code&gt;类&lt;br&gt;该类中包含以下几个子类&lt;/p&gt;
    
    </summary>
    
    
      <category term="手势" scheme="https://recherj.github.io/tags/%E6%89%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>访问通信录-适配iOS7</title>
    <link href="https://recherj.github.io/2016/04/09/%E8%AE%BF%E9%97%AE%E9%80%9A%E4%BF%A1%E5%BD%95-%E9%80%82%E9%85%8DiOS7/"/>
    <id>https://recherj.github.io/2016/04/09/访问通信录-适配iOS7/</id>
    <published>2016-04-09T13:48:42.000Z</published>
    <updated>2018-05-06T10:15:37.891Z</updated>
    
    <content type="html"><![CDATA[<p>昨天学习iOS中访问用户通信录的一个框架<code>AddressBookUI.framework</code>,这是个自带UI界面的系统框架,第一次访问要获得用户的授权.<br>因为是已经封装好的所以,用起来也比较方便</p><a id="more"></a><ol><li>导入框架<code>#import &lt;AddressBookUI/AddressBookUI.h&gt;</code></li><li><p>创建控制器</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABPeoplePickerNavigationController *Vc = [[ABPeoplePickerNavigationController alloc] init];</span><br></pre></td></tr></table></figure></li><li><p>设置控制器为代理,监听通信录控制器弹出后用户的点击操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vc.peoplePickerDelegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure></li><li><p>弹出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> presentViewController:Vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li></ol><p><code>ABPeoplePickerNavigationControllerDelegate</code>代理协议中,有两个方法可以监听用户点击操作的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person;</span><br><span class="line">- (<span class="keyword">void</span>)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier</span><br></pre></td></tr></table></figure></p><p>这两个方法的区别在于:<br>第一个方法是监听到用户点击了某个联系人时就会调用,并自动关闭页面;第二个在于点击了某个具体联系人后会自动跳转到对应联系人的详情页面,在点击具体属性时便会调用,这个方法会把这个property值传递过来,拿到这个值就可以具体获取一些具体信息了.<br>点击右上角的 Cancel按钮后会将 modal出来的界面关闭,同时调用cancel方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker</span><br></pre></td></tr></table></figure><p>以上效果均是在iOS9.2模拟器上测试的结果</p><p>为了测试真机,我将部署版本改成了 iOS7.1之后运行在我的4S老爷机上之后,发现这两个方法不调用,而且 modal 出来的控制器也关闭不了 =。=</p><p>google了一下,发现原来<code>- (void)peoplePickerNavigationController:peoplePicker didSelectPerson:</code>和<code>- (void)peoplePickerNavigationController:peoplePicker didSelectPerson: property: identifier:</code>这两个方法,是从iOS8之后才有用的,而 iOS7及以前都是要用<code>- (BOOL)peoplePickerNavigationController:shouldContinueAfterSelectingPerson:</code>和<code>- (BOOL)peoplePickerNavigationController:shouldContinueAfterSelectingPerson:property:identifier:</code>这两个方法,和iOS8之后的两个方法类似,只是iOS8之后过期了.</p><p>所以如果要适配更低的版本时,这两个过期的方法还是非常必要的.同时在 iOS7中<code>- (void)peoplePickerNavigationControllerDidCancel:</code>方法也是要自己手动弹出控制器.iOS8之后会自动弹出,所以为了适配,保证iOS7-iOS9均有效,手动dismiss掉.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天学习iOS中访问用户通信录的一个框架&lt;code&gt;AddressBookUI.framework&lt;/code&gt;,这是个自带UI界面的系统框架,第一次访问要获得用户的授权.&lt;br&gt;因为是已经封装好的所以,用起来也比较方便&lt;/p&gt;
    
    </summary>
    
    
      <category term="适配" scheme="https://recherj.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>There was an internal API error的解决方法</title>
    <link href="https://recherj.github.io/2016/04/09/There-was-an-internal-API-error%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://recherj.github.io/2016/04/09/There-was-an-internal-API-error的解决方法/</id>
    <published>2016-04-09T13:45:48.000Z</published>
    <updated>2018-05-06T10:14:02.900Z</updated>
    
    <content type="html"><![CDATA[<p>今天在真机调试二维码功能时遇到一个这样的问题”There was an internal API error”:</p><a id="more"></a><p><img src="/img/1557972-9d735075732b8414.png" alt="yizhangtu"></p><p>Google 后发现原来是product name在作怪,我之前这个程序使用了中文命名,只要将这个改成英文就 OK 了.</p><p>具体操作路径bulid settings -&gt; packaging -&gt; product name</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在真机调试二维码功能时遇到一个这样的问题”There was an internal API error”:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>故事不一定有标题</title>
    <link href="https://recherj.github.io/2016/04/09/%E6%95%85%E4%BA%8B%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%89%E6%A0%87%E9%A2%98/"/>
    <id>https://recherj.github.io/2016/04/09/故事不一定有标题/</id>
    <published>2016-04-09T13:42:06.000Z</published>
    <updated>2018-05-06T10:15:11.210Z</updated>
    
    <content type="html"><![CDATA[<p>我想，有些也堪称不了故事。</p><a id="more"></a><p>这段故事，没有结尾，没有升华，更没有跌宕的情节。</p><p>14年8月到今天，19个月。我不知是怎么从煎熬中一路走来，数不清的夜晚，寂寞与痛苦交织，撕扯着思绪，苦苦难以入眠。想必，人大抵都是孤独的，一个人来到这个世界，一个人离去。<br>昨日，许久未联系的朋友突然发来了消息，带来了她的音讯，问我想不想知道，万千思绪涌起，不甘与倔强，最总还是咬牙说出了“算了”。</p><blockquote><p>人心，是最复杂的迷宫</p></blockquote><p>越来越喜欢，思绪在心里嚼烂，哭也要笑着。<br>我不知道放下是一种怎么样的心态，我也不明白，为什么明明心里要想，去还是固执违心的说出了相反的话。成年人嘴里的成熟是不是就是这样，逼着一个人慢慢长大。虽然，我不知道她转述了什么，但此刻，我觉得也不必要了，我要的也许就是<br>各自安好，相忘于江湖……</p><p>一时间想起，那句不知道出处的话</p><blockquote><p>青春的残酷在于，你尚未意识到某人某事对你的一生有多深远的影响、或者觉得自己还有无数推倒重来的机会，于是就轻率的错过了他们。成年人的残酷在于，你已知某人某事是此生最爱，失去后永不再来，依然咬牙闭眼，狠心错过。</p></blockquote><p>错过，就错过吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想，有些也堪称不了故事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://recherj.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>《百思不得姐》项目总结-63个知识点</title>
    <link href="https://recherj.github.io/2016/04/09/%E3%80%8A%E7%99%BE%E6%80%9D%E4%B8%8D%E5%BE%97%E5%A7%90%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-63%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://recherj.github.io/2016/04/09/《百思不得姐》项目总结-63个知识点/</id>
    <published>2016-04-09T13:03:47.000Z</published>
    <updated>2018-05-06T10:13:08.572Z</updated>
    
    <content type="html"><![CDATA[<p>从2月12日开始到3月9日，一个月学习这个项目收获了很多知识点，给自己总结出来，方便以后查看。<br><a id="more"></a></p><ul><li><p>控制器的view加载完毕，首先在<code>- (void)viewDidLoad</code>方法中添加 下拉刷新 的控件；</p><p>  1.1将添加下拉刷新控件封装一个函数<code>- (void)setupRefresh</code>，该方法中添加<code>MJRefresh</code>框架的header控件<br>  1.2写一个头部控件调用的刷新方法<code>- (void)loadNewTopics</code>，里面写发送网络请求代码</p></li><li><p>在成功返回的block中调用<code>endRefreshing</code>将Header控件隐藏起来，当然失败一样也要影藏起来；</p></li><li><p>一进来TableView就应该自动刷新，所以在<code>- (void)setupRefresh</code>方法中添加完header控件，就调用它的<code>beginRefreshing</code>方法，让其自动刷新；</p></li><li><p>利用header的<code>automaticallyChangeAlpha(YES)</code>属性自动改变header的透明度，让其影藏，解决下图效果问题</p></li></ul><p><img src="/img/1557972-19285bc20226c60e.png" alt="一张图"></p><ul><li><p>利用<code>MJRefreshAutoNormalFooter</code>类添加footer控件，一开始设置footer控件<code>hidden</code>属性为YES隐藏；</p><p>  5.1<code>MJRefreshAutoNormalFooter</code>类的footer是上拉到指定位置自动刷新<br>  5.2<code>MJRefreshBackFooter</code>类刷新完会有一个回弹的效果</p></li><li>上拉刷新加载更多数据，所以将下拉刷新发送网络请求的代码同样复制一份到<code>- (void)loadMoreTopics</code>方法中，但是加载更多需要下一个的页码参数</li></ul><p><strong>网络延迟中一些细节处理</strong></p><ul><li><p>网络不好时，上拉加载更多失败了，但是page++了，下次加载就会直接跳过失败那页数据，所以在失败的block中将page—-；</p></li><li><p>加入显示处在第5页数据中，先在下拉刷新加载最新数据，但是也有可能失败，一旦下拉刷新page被清空为0了，但现在处在第5页，如果现在上拉刷新加载更多，将会重复加载第0页数据。所以改进办法就是当下拉刷新成功了，才将页码清空为0，将<code>self.page = 0</code>; 放到成功的block中；</p></li><li><p>用户有可能下拉刷新又上拉刷新<br>例如：现在用户当前处在第5页，先下拉刷新，又上拉刷新，一会下拉刷新的数据回来后，page被清空为0了，之后上拉数据回来，成功后会将第六页数据放到第5页数据后，但是第5页数据被清空了，就讲最前面的0页数据和第6页数据合在一起了。如果上拉数据失败，page—，这样当前page被减为负数，也是有问题。<br>*两种解决办法：</p><p>  （1）控制器增加一个字典成员属性params，只处理最后一次的网络请求，如果当前返回的请求和params中的请求不是同一个请求，直接return</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>.params != params) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>  （2）禁止用户同时上拉和下拉刷新，如果发现有一个在刷新，则禁止掉例外一个刷新</p></li></ul><p><strong>其他一些知识点</strong></p><ul><li><p>footer控件永远粘着cell的底部，如果一上来，TableView没有数据，那么会直接显示footer控件。所以创建完footer控件时，默认让其隐藏，同时在<code>numberOfRowInSession</code>中设置如果返回的count==0时隐藏</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.mj_footer.hidden = (<span class="keyword">self</span>.topics.count == <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置TableView内边距的一些代码放在“精华”控制器中不合适，应该放到TableView自己的控制器中，子控制器的代码应该放到子控制器</p></li><li><p>在other文件中新建一个保存常量的类（继承NSObject）,用来保存一些全局都用到的常量信息</p><p>  12.1 删除所有内容，导入.h和.m都导入<code>#import &lt;UIKit/UIkit.h&gt;</code><br>  12.2 .m中放一些const常量，.h中放一些放常量的引用同时加上<code>UIKIT_EXTERN</code></p></li><li><p>修改TableView内部的Cell的尺寸，让其左右有间距，需要重写他的setFrame方法，只需要设置一次的东西就写在<code>awakeFromNib(xib)</code>，或<code>initWithFrame(代码)</code>方法中</p></li><li><p>将createTtime字符串时间转变为NSDate格式的时间</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> *now = [<span class="built_in">NSDate</span> date]; <span class="comment">// 当前时间</span></span><br><span class="line"><span class="built_in">NSDateFormat</span> *fmt = [[<span class="built_in">NSDateFormat</span> alloc] init];</span><br><span class="line">fmt.dateformat = @“yyyy-MM-dd HH:mm:ss”;</span><br><span class="line"><span class="built_in">NSDate</span> *createtime = [fat dateWithString:topic.create_time];</span><br></pre></td></tr></table></figure></li><li><p>两个时间的比较方法<br>(1):返回一个时间间隔（s）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> delta = [now timeIntervalSinceDate:create];</span><br></pre></td></tr></table></figure></li></ul><p>(2):NSCalendar类，有一个currentCalendar方法获取当前的日历<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line"><span class="built_in">NSInteger</span> year= [calendar component:<span class="built_in">NSCalendarUnitYear</span> fromDate:now];</span><br></pre></td></tr></table></figure></p><p>其中<code>NSCalendarUnitYear</code>是一个枚举，里面有年、月、日、时、分、秒<code>components:fromDate:</code>同上一样，可以传多个枚举值，返回一个<code>NSDateCompoents</code>,里面放着年、月、日、时、分、秒<br>时间的比较:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateCompoents</span> cmps =[calendar components:枚举 fromDate:create toDate:now options:<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p><code>cmps.year</code>,<code>cmps.month</code>等就是相差的间隔。</p><ul><li><p>UITableView的Cell有一个<code>TableView：heightForRowAtIndexPath:</code>方法，直接动态计算出每一个Cell的高度，但是这个方法调用非常频繁，所以将具体计算代码放在这里会影响性能。应该给模型提供一个<code>cellHeight</code>属性，重写该属性的getter方法，将计算的代码放这里。并且加一个if判断，如果_cellHeight没有值，才进行计算，这样就保证只计算一次，提升性能。但是提供这样一个属性暴漏在外面，别人很有可能会修改属性，所以加上readonly。</p></li><li><p>如果一个成员变量加了<code>readonly</code>，又重写了<code>getter</code>方法，那么getter方法中的成员变量就会报错，因为编译器认为有<code>readonly</code>的只生成getter方法，自己又实现了getter方法，意味着成员变量也需要自己实现，所以报错。这时，就需要我们自己再实现成员变量，在.m中加上<code>_cellheight</code>的成员变量。</p></li><li><p><code>- boundingRectWithSize:options:attributes:context:</code>方法是根据文字的大小、宽度，动态计算出这段文字的高度。</p></li><li><p>iPhone默认是不支持gif图片播放的，必须将一个gif图片解析成n个<code>UIImage</code>对象才能进行播放，用到ImageIO框架</p></li><li><p><code>imageView的contentMode</code>属性中有一个<code>UIViewContentModeScaleToFit</code>属性，表示，缩放图片比例，在现有的显示尺寸的大小内，保证看到图片的全部。另外<code>UIViewContentModeScaleToFill</code>模式是，等比例伸缩，然后在现有显示尺寸的大小内，显示伸缩后的图片的中间部分，但是剩余的头尾剩余部分也会显示出来，会遮盖其他控件，所以在显示图片的iamgeView右侧栏中间的模式中，勾选<code>Clip Subviews</code>即可将多余的部分裁剪掉。</p></li><li><p>带有图片的段子，为了提高用户体验，在图片没有下载完之前，</p><p>  1.先显示占位图片；<br>  2.提供一个下载的进度条；</p></li><li><p>屏蔽第三方框架带来的风险，就是自己建立一下类，然后继承自框架的类，这样面向自己类做开发，以后如果不用这个框架了只需要改这个类即可，这样减少不用框架后多处修改代码的风险</p></li><li><p><code>-(void)UIImageWriteToSavedPhotosAlbum(UIImage *image, id completionTarget, SELcompletionSelector, void *contextInfo );</code><br>用来将图片保存进用户的相册，第一次调用会弹框询问。</p></li><li><p>图片段子中的图片，自定义一个类，继承<code>UIView</code>，提供一个类方法返回一个创建好的UIView</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>) owner:<span class="literal">nil</span> options:<span class="literal">nil</span>] lastObject];</span><br></pre></td></tr></table></figure></li><li><p>根据模型的内容（图片、声音or视频？），将<code>UIView</code>添加到对应的cell中，所以在模型属性的setter方法中写；</p></li><li><p>为了保证只创建一次<code>UIView</code>，Cell来回滚动时可以循环利用，所以采用懒加载,但是控件都是弱指针，代码段执行完控件就死了，所以在懒加载中直接将控件下到<code>contentView</code>中</p></li><li><p>图片段子中的图片，需要给自定义的图片View增加一个topic模型,然后在if判断中若为图片段子则将topic模型传递给图片view的模型中，这样view才能拿到数据，设置数据到对应的view中去显示</p></li><li><p>如果Cell的尺寸做了修改，Cell内部的子控件<code>frame</code>尺寸不对，则将<code>autoresizingMask</code>属性设置为NO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingNone</span>;</span><br></pre></td></tr></table></figure></li><li><p>判断gif图片标志的显示或隐藏</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断GIF是否显示</span></span><br><span class="line"><span class="built_in">NSString</span> *extensionName = topic.large_image.pathExtension;</span><br><span class="line"><span class="keyword">self</span>.gifView.hidden = ![extensionName.lowercaseString isEqualToString:<span class="string">@"gif"</span>];</span><br></pre></td></tr></table></figure></li><li><p>在不知道图片扩展名的情况下，<code>SDWebImage</code>框架中有一个方法，可以取出图片数据的第一个字节，进行判断，获得图片的扩展名，这种方式是最准确的</p></li><li><p>发布按钮点击后，一进来，几个button在执行动画的过程中，应该让按钮不能被点击，所以在控制器的<code>viewDidLoad</code>方法中设置<br><code>self.view.userInteractionEnabled = NO</code>; (不响应用户交互事件)，动画执行完毕（最后标语落下来时），在setCompetionBlock这个block中恢复view的点击事件；</p></li><li><p><code>UIWindow</code>有三个级别，<code>Normal &lt; StatusBar &lt; Alert</code>依次升高。如果想做一个动画，在状态栏提示一些东西，就创建一个Window，设置为状态栏级别，挡住系统自带的状态栏，因为状态栏就是一个<code>StatusBar</code>级别的window。</p></li><li><p>命名规范</p></li></ul><p>（1）成员变量访问以下滑线开头；<br>（2）全局变量可以在名称后面加一个下划线与成员变量区分；<br>（3）如果没有任何东西就是局部变量</p><ul><li><p>发布按钮，一进来动画在执行的过程中，让下降的按钮应该不能被点击，所以在<code>viewDidLoad</code>中让<code>view.userInteractionEnabled = NO</code>，在动画执行完毕后再恢复能点击,在 setCompletionBlock:^的block中恢复</p></li><li><p>reloadData刷新表格时就会调用数据源的三个方法</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><ul><li><p>header和cell一样也可以循环利用<code>dequeueReusableHeaderFooterViewWithIdentifier:</code>利用这个方法从缓存池中找这个标识的headerfooterView，返回一个<code>UITableViewHeaderFooterView</code></p></li><li><p>从iOS8开始提供了一个自动计算Cell高度尺寸的属性，先给出估算高度，然后让真实高度根据具体尺寸伸缩</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure></li><li><p>连续点击两次tabBar自动刷新当前窗口中的TableView,是有通知完成，系统的delegate成为<code>tabBarController</code>的代理，当tabBar被点击时，发出一个通知。对应的TableViewController接到通知，调用自己的头部控件开始刷新</p></li><li><p>UIView没有图片属性，也没有背景图片属性，所以要给UIView添加背景需要调用<code>drawRect:</code>方法画上去</p></li><li><p>监听textFiled的文字改变可以用三种方法：</p></li></ul><p>（1）<strong>代理</strong> - 成为代理——&gt;遵守协议——&gt;实现方法 （不推荐）<br>（2）<strong>通知</strong> 有一个<code>UITextFiledDidChangeNotification</code><br>（3）<strong>addTarget</strong> textFiled继承自<code>UIControl</code></p><ul><li><p>从iOS7以后</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIBarButtonItemStyleDone</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(cancel)];</span><br><span class="line">style样式写什么都一样</span><br></pre></td></tr></table></figure></li><li><p>设置导航控制器view上的标题文字大小的两种方式</p></li></ul><p>（1）<code>UIViewController</code>被导航控制器包装后拿到titleView属性,自己包装一个UIView,里面放一个Label将文 字调整一下<code>self.navigationItem.titleView</code><br>（2）拿到<code>navigationBar</code>属性，在<code>navigationController</code>的<code>initialize</code>方法中设置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.navigationController.navigationBar setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">20</span>]&#125;];</span><br></pre></td></tr></table></figure></p><ul><li><p>如果在<code>navigatioController</code>利用<code>appearance</code>分状态修改了<code>UIBarButtonItem</code>的属性，那么在控制器中设置<code>rightBarButtonItem</code>状的enabled的属性之后，要调用<code>layoutifNeeded</code>函数强制刷新</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.navigationController.navigationBar layoutIfNeeded];</span><br></pre></td></tr></table></figure></li><li><p><code>UITextView</code>没有占位文字，可以自定义一个继承自UITextView，增加一个<code>placeholder</code>属性的UITextView，方法有两种：</p></li></ul><p>（1）实现<code>- (void)drawRect:(CGRect)rect</code>将文字画上去<br>（2）给TextView增加一个子控件Label,来显示占位文字，好处是，子控件可以在textView实现滚动效果</p><ul><li>监听<code>UITextView</code>的文字改变有很多中方法</li></ul><p>（1）<strong>通过代理</strong>，有一个TextViewDidChange:方法可以监听文字的改变，但是不推荐这种方法，因为控制器要成为代理来监听控件的改变，高耦合性，占位文字是控件内部的功能，应该由自己来控制或隐藏<br>（2）TextView文字发生改变会发出<strong>通知</strong>UITextViewDidChangeNotification</p><ul><li><p>如果监听了通知，一定要调用<code>dealloc</code>方法，将监听删除</p></li><li><p>文字一旦改变就会调用监听方法，在监听方法中调用<code>setNeedsDisplay</code>方法重新绘制，因为<code>setNeedsDisplay</code>会调用<code>DrawRect:</code>方法，该方法每次进来会将之前的内容擦掉，重新绘制一次</p></li><li><p><code>UITextView</code>给别人提供一个占位文字的属性，别人很有可能随时更改这个属性值，所以要重写属性的setter方法，时时监听属性的修改,需要重写以下几个方法,同时都要调用<code>setNeedsDisplay</code>方法</p><p>  (1) 重写占位文字的属性方法<br>  (2) 重写字体属性的setter方法，因为字体别人也有可能修改，同样也要调用<br>  (3) 别人可能通过代码修改text值，所有也要重写setText:方法（调用父类的该方法）<br>  (4)别人修改的也有可能是富文本属性AttributedText，所有这个属性也要重写</p></li><li><p>TextView继承<code>UIscrollView</code>，所以他是能滚动的，其中有一个属性<code>alwaysBounceVertical</code>，在竖直方向上有弹簧效果</p></li><li><p>增加的label采用懒加载先确定位置，如果label的宽度确定，高度是要通过文字计算出来，所以在<code>layoutSubviews</code>方法中计算根据文字数量和字体大小确定后的label的尺寸，但是控制器中有可能随时修改这个尺寸和文字，所以要在setter方法中调用setNeedsLayout方法在恰当的时间重新计算更新后的label的尺寸</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  更新label的尺寸</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>( <span class="keyword">self</span>.width - <span class="number">2</span> * <span class="keyword">self</span>.phLabel.x, MAXFLOAT);</span><br><span class="line">    <span class="keyword">self</span>.phLabel.size = [<span class="keyword">self</span>.placeholder boundingRectWithSize:size options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : <span class="keyword">self</span>.font&#125; context:<span class="literal">nil</span>].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>setNeedsDisplay</code>会在恰当的时候调用<code>drawRect:</code>方法<br><code>setNeedsLayout</code>会在恰当时候调用<code>layoutSubviews</code>方法</p></li><li><p>通过代码设置创建按钮的尺寸和图片的尺寸一样的方法</p><p>  （1）<code>button.size = [UIImage ImageNamed:@“tag_add_icon”].size;</code><br>  （2）取出普通状态下的图片<code>button.size = [button iamgeForState:UIControlStateNormal].size</code>;<br>  （3）获取正在展示的图片<code>button.size = button.currentImage.size</code>;</p></li><li><p>一旦根控制器modal出一个控制器，就会用<code>presentedViewController</code>属性引用着它。</p></li></ul><p>a.<code>presentedViewController</code> -&gt; b a控制器的这个属性可以找到弹出的b控制器<br>b.<code>presentingViewController</code> -&gt; a b控制器的这个属性可以找到谁把他push出来了</p><ul><li><p>监听TextFiled的文字改变的三种方法：</p><p>  （1）<strong>代理方法</strong>，但对中文的支持不好，不推荐<br>  （2）<strong>通知</strong><code>UITextFieldTextDidChangeNotification</code><br>  （3）<code>addTarget:</code>方法</p></li><li><p>按钮的<code>contenMode</code>属性用在内部的image身上，对文字的对齐方式不起作用,<code>contentHorizontalAlignment</code>属性，是设置按钮内部文字或图片水平方向的排布</p></li><li><p>右下角的换行不是字符，所以不能通过<code>addTarget:</code>方法中的点击方法监听，要通过代理监听</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textFieldShouldReturn:(<span class="built_in">UITextField</span> *)textField</span><br></pre></td></tr></table></figure></li><li><p><code>- (void)deleteBackard</code>是监听键盘的删除按键</p></li><li><p>自己定义的Block很容易发生循环引用，所以一定要用弱引用</p></li><li><p>布局控制器view中的子控件位置和尺寸的代码最好放到<code>viewDidLayoutSubviews</code>方法中，因为控制器的view有可能是通过xib、代码、storyboard创建，所以一开始初始化时的尺寸是不准确的。但是当view布局完成后的尺寸是最准确的</p></li><li><p>Xcode中蓝色文件夹表示在项目中真实存在</p></li><li><p><code>ABS()</code>是取绝对值函数</p></li><li><p><code>- (void)prepareLayout</code>用来做布局的初始化操作(不建议在 init 方法中进行布局的初始化操作)</p></li><li><p><code>- (NSDictionary *)attributesOfItemAtPath:(NSString *)path error:(NSError **)error</code>;这个方法获取文件大小是可靠的,文件计算不准确</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2月12日开始到3月9日，一个月学习这个项目收获了很多知识点，给自己总结出来，方便以后查看。&lt;br&gt;
    
    </summary>
    
    
      <category term="项目总结" scheme="https://recherj.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITextView实现占位文字的两种方法</title>
    <link href="https://recherj.github.io/2016/04/09/UITextView%E5%AE%9E%E7%8E%B0%E5%8D%A0%E4%BD%8D%E6%96%87%E5%AD%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://recherj.github.io/2016/04/09/UITextView实现占位文字的两种方法/</id>
    <published>2016-04-09T12:41:37.000Z</published>
    <updated>2018-05-06T10:14:29.035Z</updated>
    
    <content type="html"><![CDATA[<p>在Cocoa Touch框架中有两种系统自带的文本输入控件：<code>UITextFiled</code>和<code>UITextView</code></p><a id="more"></a><ul><li>UITextFiled特点<ul><li>只显示一行文本输入</li><li>高度（30）默认不能修改</li><li>没有拖拽滚动(父控件是UIscrollView除外)</li></ul></li><li>UITextView特点<ul><li>支持多行输入显示</li><li>支持滚动（继承自UIscrollView）</li><li>没有占位文字（placeholder）</li><li>本质就是一个可调整的多行输入文本框<br>有时候我们希望给一个多行文本框增加一个占位文字的功能，来提示用户输入的内容。但是这两种都不能满足我们的要求，这样我们可以自定义一个这样的控件，实现我们的需要。</li></ul></li></ul><p>实现思路：<br><strong>自定义一个类，继承自UITextView，在现有功能的基础上增加一个占位文字的功能</strong></p><p>两种实现方法：</p><ol><li><p>实现UITextView内部的- (void)drawRect:(CGRect)rect方法，将占位文字文字画到UITextView控件上<br> 1.1 在.h的头文件中给外界提供一个占位文字的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  占位文字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *placeholder;</span><br></pre></td></tr></table></figure><p> 1.2 将占位文字画到矩形框中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  绘制占位文字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attrs = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    attrs[<span class="built_in">NSFontAttributeName</span>] = <span class="keyword">self</span>.font;</span><br><span class="line">    attrs[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    <span class="comment">// 在textView的矩形框中绘制文字</span></span><br><span class="line">    [<span class="keyword">self</span>.placeholder drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.height) withAttributes:attrs];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注：label的font要在初始化时确定，不然程序会奔溃<br>    1.3 采用通知的方式监听键盘文字的改变。文字一旦改变，会发出一个<code>UITextViewTextDidChangeNotification</code>的通知，所以给TextView初始化后就添加一个监听器<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">// 添加监听器，监听自己的文字改变通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(textDidChange) name:<span class="built_in">UITextViewTextDidChangeNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时刻监听文字键盘文字的变化，文字一旦改变便调用setNeedsDisplay方法</span></span><br><span class="line">- (<span class="keyword">void</span>)textDidChange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 该方法会调用drawRect:方法，立即重新绘制占位文字</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.4 添加监听器就要重写dealloc方法，当控件被销毁时，移除监听器<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.5 用户一旦输入了文字，就需要将绘制的占位文字删除掉，所以在<code>drawRect:</code>方法一进来就增加判断</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一旦有输入文字，直接返回，不再绘制占位文字</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasText) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>因为<code>drawRect:</code>方法是每次调用会将上次绘制的内容删除掉，重新绘制，所以增加一个这样的判断，当有文字时，再重绘时直接返回，不进行后面的绘制，这样就可以办到有文字输入后，删除占位文字</p><p>但其实还有一些问题，控制器中拿到这个textView控件后，可能会随时修改占位文字的字体大小、占位文字的内容，所以避免这些问题，随时响应修改，就需要重写这些属性的setter方法<br>    1.6 重写字体、占位文字等属性的setter方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位文字的setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setPlaceholder:(<span class="built_in">NSString</span> *)placeholder</span><br><span class="line">&#123;</span><br><span class="line">    _placeholder = placeholder;</span><br><span class="line">    <span class="comment">// 文字一旦改变，立马重写绘制（内部会调drawRect:方法）</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字体属性setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setFont:(<span class="built_in">UIFont</span> *)font</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFont:font];</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这个在系统自带控件基础上自定义的<code>UITextView</code>控件就有占位文字功能了。</p><p><img src="/img/1557972-334aa4e9780dfa54.png" alt="成果图"></p><ol><li><p>给自定TextView控件增加一个label属性，用来显示占位文字<br>这里，相同的部分就不在贴代码，只阐述实现步骤和思路<br> 2.1 在.m文件类扩展增加一个label属性，（写在类扩展中是为了将子控件私有化，不暴漏在外部让被人随意修改属性值）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  占位文字Label</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UILabel</span> *phLabel;</span><br></pre></td></tr></table></figure><p> 2.2 重写getter方法，采用懒加载，不用关心控件的创建时间，用到时自动加载，同时初始化一些属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UILabel</span> *)phLabel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_phLabel) &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *phLabel = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">         <span class="comment">// 文字自动换行</span></span><br><span class="line">        phLabel.numberOfLines = <span class="number">0</span>; </span><br><span class="line">        phLabel.x = <span class="number">4</span>;</span><br><span class="line">        phLabel.y = <span class="number">7</span>;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:phLabel];</span><br><span class="line">        <span class="keyword">self</span>.phLabel = phLabel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _phLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.3 给控件添加监听器，代码同上1.3<br> 2.4 重写dealloc方法，移除监听器，同上1.4<br> 2.5 在- (void)textDidChange方法中控制label的显示或隐藏</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)textDidChange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有文字就隐藏</span></span><br><span class="line">    <span class="keyword">self</span>.phLabel.hidden = <span class="keyword">self</span>.hasText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.6 在<code>- (void)layoutSubviews</code>方法中动态计算占位文字的label大小</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="comment">// 确定label的宽度，高度由文字数量自动计算</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.width - <span class="number">2</span> * <span class="keyword">self</span>.phLabel.x, MAXFLOAT);</span><br><span class="line">   <span class="comment">// 根据文字的字体属性、文字的数量动态计算label的尺寸</span></span><br><span class="line">    <span class="keyword">self</span>.phLabel.size = [<span class="keyword">self</span>.placeholder boundingRectWithSize:size options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : <span class="keyword">self</span>.font&#125; context:<span class="literal">nil</span>].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：label的font要在初始化时确定，不然程序会奔溃<br>    2.7 重写字体、占位文字的setter方法(满足控制器中可能随时修改占位文字的尺寸和大小)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位文字</span></span><br><span class="line">- (<span class="keyword">void</span>)setPlaceholder:(<span class="built_in">NSString</span> *)placeholder</span><br><span class="line">&#123;</span><br><span class="line">    _placeholder = placeholder;</span><br><span class="line">    <span class="keyword">self</span>.phLabel.text = placeholder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新文字尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsLayout];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字体</span></span><br><span class="line">- (<span class="keyword">void</span>)setFont:(<span class="built_in">UIFont</span> *)font</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFont:font];</span><br><span class="line">    <span class="keyword">self</span>.phLabel.font = font;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setNeedsLayout</code>方法会在控件尺寸变化时调用<code>layoutSubviews</code>重新计算子控件的尺寸和大小</p><p>这种方式增加的占位文字有一个优势：</p><blockquote><p>占位文字可以跟随光标一起拖拽上下移动（弹簧效果），但利用<code>drawRect:</code>画上去的占位文字是固定的，没有拖拽效果</p></blockquote><p>控制器在拿到这个控件后，设置占位文字后就可以直接用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Cocoa Touch框架中有两种系统自带的文本输入控件：&lt;code&gt;UITextFiled&lt;/code&gt;和&lt;code&gt;UITextView&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈UITableView内Cell的选中细节过程</title>
    <link href="https://recherj.github.io/2016/04/09/%E6%B5%85%E8%B0%88UITableView%E5%86%85Cell%E7%9A%84%E9%80%89%E4%B8%AD%E7%BB%86%E8%8A%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://recherj.github.io/2016/04/09/浅谈UITableView内Cell的选中细节过程/</id>
    <published>2016-04-09T12:34:31.000Z</published>
    <updated>2018-05-06T10:15:32.558Z</updated>
    
    <content type="html"><![CDATA[<p>UITableView的代理协议中给代理者提供了4个代理方法，用来监听从选中一个cell到选中另一个cell的切换过程，当然代理必须实现这些方法，才能监听整个cell的点击切换过程。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将要选中</span></span><br><span class="line">- (<span class="built_in">NSIndexPath</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView willSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line"><span class="comment">// 选中 </span></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line"><span class="comment">// 将要取消选中</span></span><br><span class="line">- (<span class="built_in">NSIndexPath</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView willDeselectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line"><span class="comment">// 取消选中</span></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didDeselectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><ol><li>当第一次点击某个cell时<br> 1.1 首先调用代理的<code>- willSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>方法，并将选中的<code>indexPath</code>对象返回给代理，其中包含选中的这组section组号和row行号<br> 1.2 紧接着，马上会调<code>- didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>方法，告诉代理选中了该cell</li><li>再点击另一个Cell时<br> 2.1 首先调<code>- willSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>方法，告诉代理有一个新Cell将要被选中，并将这个新cell的indexPath返回给代理<br> 2.2 然后调<code>willDeselectRowAtIndexPath:(NSIndexPath *)indexPath</code>方法，告诉代理即将取消选中上一个cell<br> 2.3 接着调<code>didDeselectRowAtIndexPath:(NSIndexPath *)indexPath</code>取消选中上一个cell<br> 2.4 最后调<code>didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>选中新cell<br>明白了这些cell选中的细节过程，我们就可以让控制器成为TableView的代理，监听其内部的点击事件，完成一些转场动画、弹框提示、modal新控制器或者修改cell内数据时，传递数据给下一个控制器等等一些详细操作了。<br>例如，可以不用push新控制器修改数据的方式，直接将修改后的数据在原来的view中刷新，将刷新表格的代码写在<code>willDeselectRowAtIndexPath:(NSIndexPath *)indexPath</code>中，这样修改后点击新cell，新数据自动刷新，不用上下拉滚动cell来刷新；<br>再例如，当点击某个cell，界面显示一些友好的文字提示，之后慢慢消失。整个view的显示、透明度变化、消失、view的最终删除等一系列动画过程的相关代码，就可以放在<code>didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>方法中完成<br>等等<br>……</li></ol><p>总之，在明白了这个cell点击函数调用的先后顺序后，我们就可以做很多事情了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView的代理协议中给代理者提供了4个代理方法，用来监听从选中一个cell到选中另一个cell的切换过程，当然代理必须实现这些方法，才能监听整个cell的点击切换过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
